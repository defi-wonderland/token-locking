"use strict";var e,r=require("@solana/web3.js"),t=require("@solana/spl-token"),n=require("bn.js"),i=require("bs58");function s(e,t,n,i,s){let o=[Buffer.from(Int8Array.from([0]).buffer),Buffer.concat(s)];const a=Buffer.concat(o),c=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:r.SYSVAR_RENT_PUBKEY,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0}];return new r.TransactionInstruction({keys:c,programId:t,data:a})}function o(e,t,n,i,s,o,a,c,u,f){let l=[Buffer.from(Int8Array.from([1]).buffer),Buffer.concat(f),c.toBuffer()];l.push(u.toBuffer());const d=Buffer.concat(l),g=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!0,isWritable:!1},{pubkey:a,isSigner:!1,isWritable:!0}];return new r.TransactionInstruction({keys:g,programId:e,data:d})}function a(e,t,n,i,s,o,a){const c=Buffer.concat([Buffer.from(Int8Array.from([2]).buffer),Buffer.concat(a)]),u=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0}];return new r.TransactionInstruction({keys:u,programId:e,data:c})}function c(e,t,n,i,s,o,a){const c=Buffer.concat([Buffer.from(Int8Array.from([3]).buffer),Buffer.concat(a)]),u=[{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0}];return new r.TransactionInstruction({keys:u,programId:e,data:c})}exports.Instruction=void 0,(e=exports.Instruction||(exports.Instruction={}))[e.Init=0]="Init",e[e.Create=1]="Create";class u extends n{toBuffer(){const e=super.toArray().reverse(),r=Buffer.from(e);if(8===r.length)return r;if(r.length>8)throw new Error("Numberu64 too large");const t=Buffer.alloc(8);return r.copy(t),t}static fromBuffer(e){if(8!==e.length)throw new Error(`Invalid buffer length: ${e.length}`);return new n([...e].reverse().map((e=>`00${e.toString(16)}`.slice(-2))).join(""),16)}}class f{constructor(e,r){this.timeDelta=e,this.amount=r}toBuffer(){return Buffer.concat([this.timeDelta.toBuffer(),this.amount.toBuffer()])}static fromBuffer(e){const r=u.fromBuffer(e.slice(0,8)),t=u.fromBuffer(e.slice(8,16));return new f(r,t)}}class l{constructor(e,r,t){this.destinationAddress=e,this.mintAddress=r,this.isInitialized=t}static fromBuffer(e){return{destinationAddress:new r.PublicKey(e.slice(0,32)),mintAddress:new r.PublicKey(e.slice(32,64)),isInitialized:1==e[64]}}}class d{constructor(e,r,t){this.destinationAddress=e,this.mintAddress=r,this.schedules=t}static fromBuffer(e){const r=l.fromBuffer(e.slice(0,65));if(!r.isInitialized)return;const t=[];for(let r=65;r<e.length;r+=16)t.push(f.fromBuffer(e.slice(r,r+16)));return new d(r.destinationAddress,r.mintAddress,t)}}const g=new r.PublicKey("CChTq6PthWU82YZkbveA3WDf7s97BWhBK4Vx9bmsT743");async function b(e,r){console.log("Fetching contract ",r.toBase58());const t=await e.getAccountInfo(r,"single");if(!t)throw new Error("Vesting contract account is unavailable");const n=d.fromBuffer(t.data);if(!n)throw new Error("Vesting contract account is not initialized");return n}exports.ContractInfo=d,exports.Numberu32=class extends n{toBuffer(){const e=super.toArray().reverse(),r=Buffer.from(e);if(4===r.length)return r;if(r.length>4)throw new Error("Numberu32 too large");const t=Buffer.alloc(4);return r.copy(t),t}static fromBuffer(e){if(4!==e.length)throw new Error(`Invalid buffer length: ${e.length}`);return new n([...e].reverse().map((e=>`00${e.toString(16)}`.slice(-2))).join(""),16)}},exports.Numberu64=u,exports.Schedule=f,exports.TOKEN_VESTING_PROGRAM_ID=g,exports.VestingScheduleHeader=l,exports.create=async function(e,n,a,c,u,f,l,d,g){null==f&&(f=await t.getAssociatedTokenAddress(d,u,!0)),a=a.slice(0,31);const[b,p]=await r.PublicKey.findProgramAddress([a],n),m=await t.getAssociatedTokenAddress(d,b,!0);if(a=Buffer.from(a.toString("hex")+p.toString(16),"hex"),console.log("Vesting contract account pubkey: ",b.toBase58()),console.log("contract ID: ",i.encode(a)),await e.getAccountInfo(b))throw"Contract already exists.";return[s(r.SystemProgram.programId,n,c,b,[a]),t.createAssociatedTokenAccountInstruction(c,m,b,d),o(n,t.TOKEN_PROGRAM_ID,r.SYSVAR_CLOCK_PUBKEY,b,m,u,f,d,g,[a])]},exports.createCreateInstruction=o,exports.createInitInstruction=s,exports.createInitializeUnlockInstruction=c,exports.createUnlockInstruction=a,exports.generateRandomSeed=()=>{let e="";for(let r=0;r<64;r++)e+=Math.floor(10*Math.random());return e},exports.getContractInfo=b,exports.initializeUnlock=async function(e,n,i,s){i=i.slice(0,31);const[o,a]=await r.PublicKey.findProgramAddress([i],n);i=Buffer.from(i.toString("hex")+a.toString(16),"hex");const u=await t.getAssociatedTokenAddress(s,o,!0),f=await b(e,o);return[c(n,t.TOKEN_PROGRAM_ID,r.SYSVAR_CLOCK_PUBKEY,o,u,f.destinationAddress,[i])]},exports.unlock=async function(e,n,i,s){i=i.slice(0,31);const[o,c]=await r.PublicKey.findProgramAddress([i],n);i=Buffer.from(i.toString("hex")+c.toString(16),"hex");const u=await t.getAssociatedTokenAddress(s,o,!0),f=await b(e,o);return[a(n,t.TOKEN_PROGRAM_ID,r.SYSVAR_CLOCK_PUBKEY,o,u,f.destinationAddress,[i])]};
